# ISO reinterpret_cast

> Ref: ISO/IEC 14887



## 对`intepret_cast`的定义

> P129
>
> 8.2.10 Reinterpret cast

1. `reinterpret_cast<T>(v)`的结果是把`v`转化为`T`类型。当`T`是左值引用类型或对函数的右值类型时，结果是左值；如果`T`是对对象的右值引用类型，结果是消亡值；其他情况下，结果是纯右值且将对`v`执行左值到右值、数组到指针、函数到指针的标准转换。仅有如下列举的转换可以通过`reinterpret_cast`执行。
2. `reintperpret_cast`不能去除常量性。一个整型、枚举型、指向成员指针类型可以被显式转换本身的类型；这样转换的结果就是原操作数的值。
3. 注：`reinterpret_cast`执行的映射可能会、也可能不会造成与原有值的改变。
4. 一个指针可以转换为任意足够大的整型。此时映射函数依赖于具体实现[注：对于那些熟知机器底层地址架构的人来说，这一点不会使他们惊讶。] 一个`std::nullptr_t`类型的值可以转换为整型类型，这个转换的含义及合法性与将`(void*)0`转换为整型是相同的。[注：`reinterpret_cast`不能把任何类型的值转换为`std::nullptr_t`。]
5. 一个整型类型或枚举类型的值可以显式地转换为指针。把一个指针转换为一个足够大的整型类型再转换回原指针类型的值就是最初指针的值；否则指针和整型之间的映射关系是实现依赖的。注：除了6.7.4.3描述的情况外，这样的转换不会是一个`safely-derived`类型的指针。
6. 一个函数的指针可以显式地转换为另一个函数类型的指针。[注：尝试把一个函数指针转换为另一个函数指针类型后再调用将导致未定义行为。] 除了把“指向`T1`的纯右值指针”转换为“指向`T2`的指针”(这里`T1`和`T2`是函数类型)再转换回原类型的结果就是原指针的值以外，这样的指针转换结果是不确定的。[注：对于指针转换更详细的细节，参见7.11]
7. 一个对象的指针可以转换为另一类型的对象的指针。<sup>1</sup> 当一个对象纯右值指针类型被转换为“指向 cv T”的指针类型时，结果等价为`static_cast<cv T*>(static_cast<cv void*>(v))`。[注：把“指向T1”的纯右值指针转换为“指向T2”的指针且`T1`、`T2`都是对象类型且`T2`的对齐要求不比`T1`严格时，再把结果转换回原类型得到的指针值等于最初的指针值。]
8. 在某些情况下，把函数指针转换为对象指针或反方向转化是得到支持的。这样的转化的含义依赖于具体实现，除非某个实现支持两个方向的转化，把一个类型的纯右值转化为另一个类型再转换原类型，尽管cv限定符可能有所不同，但其值就是最初指针的值。
9. 空指针的值可以转换为目标类型的空指针。注：一个`std::nullptr_t`类型的空指针常量不能被转换为一个指针类型，且一个整型类型的空指针常量没有必要转换为空指针。
10. 一个“指向`T1`类型的X成员”的纯右值指针可以被显式地转换为一个不同的“指向`T2`类型的Y成员的纯右值指针”，这里`T1`和`T2`都是函数类型或都是对象类型。<sup>2</sup> 成员空指针可以被转换为目标类型的成员空指针。除了下述情况外，其他转换的结果是不确定的：
    - 把“指向成员函数的指针“转换为另一个指向成员函数指针类型，再把它转换回原来的类型得到的指针就是最初的指针。
    - 把一个“指向T1类型X成员数据的指针”转换为“指向T2类型的Y成员”的指针(这里要求T2的内存对齐要求不比T1严格)，再把它转换为原来的类型，得到的就是最初的指针。
11. 如果“指向`T1`的指针“类型可以使用`reinterpret_cast`显式地转换为“指向`T2`的指针”类型，那么一个`T1`类型的泛左值表达式可以被转换为`T2`类型的引用。结果指向与原泛左值相同的对象，但对象的类型有所不同。[注：意思是对于左值，`reinterpret_cast<T&>(x)`与`*reinterpret_cast(T*)(&x)`有相同的效果，对于`reinterpret_cast<T&&>(x)`同理] 这个转换不会创建任何临时对象、不会进行任何拷贝、不会调用构造函数或转换函数。<sup>3</sup>



上标解释部分：

1. & 2. 在`reinterpret_cast`不能去除常量性的条件下，这些类型可能具有不同的cv限定符。

3. 这有时被称为类型双关(type pun)。





## 其余出现位置

> P40
>
> 5.11 Keywords
>
> 表格5

`reinterpret_cast`是保留关键字。



> P85
>
> 6.7.4.3 Safely-derived pointers
>
> 条目2、条目3、条目4

条目2：有关`safely-derived pointer`的定义。

条目3：整型值是`safely-derived`指针的整型表现的条件。

条目4：对于两个可互换对象的指针，可以通过`reinterpret_cast`从一个指针获取另一个指针。



> P121
>
> 8.2 Postfix expression
>
> 条目1、条目2

条目1：`reinterpret_cast`是后缀表达式。

条目2：在解析`reinterpret_cast`时，`>>`符号被理解为两个`>`而不是右移符号。



> P141
>
> 8.4 Explicit type conversion (cast notation)
>
> 条目2、条目4、条目5

条目2：可以使用`reinterpret_cast`进行显示隐式转换。

条目4：`reinterpret_cast`的功能被C语言风格的转换语法覆盖。

条目5：如果源类型和目标类型都是不完整类型，`reinterpret_cast`的结果是不确定的。



> P152
>
> 8.20 Constant expressions
>
> 条目2

与一个表达式是核心常量表达式(core constant expression)的条件有关。



> P396
>
> 17.6.2.2 Type-dependent expressions
>
> 条目3

与类型依赖相关。



> P397
>
> 17.6.2.3 Value-dependent expressions
>
> 条目3

当`type-id`或`expression`是值依赖(value-dependent)时，`reinterpret_cast`是值依赖的。



> P640
>
> 23.11.2.2.9 shared_ptr cast
>
> 条目10、条目11、条目12

使用`reinterpret_cast`定义了一系列的函数。



> P1061
>
> 29.5 Complex numbers
>
> 条目4

这一条比较有意思。

假设`z`是类型`cv complex<T>`的一个左值，那么：

* 表达式`reinterpret_cast<cv T(&)[2]>(z)`是规范良好的(well-formed)。
* `reinterpret_cast<cv T(&)[2]>(z)[0]`代表 z 的实部，且
* `reinterpret_cast<cv T(&)[2]>(z)[0]`代表 z 的虚部。

更进一步，如果`a`的类型是`cv complex<T>*`且对于整型`i`表达式`a[i]`是规范良好的，那么：

* `reinterpret_cast<cv T*>(a)[2*i]`代表`a[i]`的虚部，且
* `reinterpret_cast<cv T*>(a)[2*i+1]`代表`a[i]`的实部。



> P1216
>
> 30.7.5.2.4 character inserter function templates
>
> 条目4

借助`reinterpret_cast`来定义函数。



> P1427
>
> 附录A



> P1542
>
> 索引

