{"./":{"url":"./","title":"类型转换符报告","keywords":"","body":"C++ 类型转换运算符 研究报告 Author: JCav E-mail: micojcav@outlook.com 摘要 在C语言中的类型转换非常简单，只需要形如(new-type)expression的代码即可完成各种类型的转换，这样简洁的语法给予程序员便捷的同时也引入了风险：有些转换是非常怪异但是有用的，有些却会造成致命的Bug。C++通过对各种类型转换进行归类，引入了四个新的类型转换运算符来减少类型转换中可能出现的错误。 dynamic_cast：借助RTTI，进行安全地向下转型。 const_cast：用于修改变量的cv修饰符。 static_cast：进行隐式转换或自定义转换。 reinterpret_cast：风险极高的对二进制位的重新解释。 本报告的组织方式 目录结构 目录结构及其说明如下： cast-expr/ archive/：参考文献保存，包括网页快照、书籍等资料 asset/：报告中使用的图片等资源 snippet/：示例代码 brief-intro.md：对四个转换的简要说明 dynamic_cast.md：对运算符的详细说明，下同 const_cast.md static_cast.md reinterpret_cast.md ISO dynamic_cast.md：C++标准中的定义，下同 ISO const_cast.md ISO static_cast.md ISO reinterpret_cast.md 简要-详细-定义 设计 对四个运算符的说明都分为三个部分：简要说明、详细说明、定义。其中： brief-intro.md中包含了所有的简要说明。简要说明的目的是让没有了解过这四个运算符的人看完之后可以不考虑细节地直接使用这三个运算符，简要说明涵盖了运算符最常见的使用方式和最常见的误用方式，足以覆盖大多数情况。简要说明中基本不会涉及到“左值”、“右值”等的令人眩晕的名词，避免加大理解难度。 详细说明部分除了dynamic_cast外，基本翻译自cppreference网站。这一部分的目的是明确各个表达式的具体行为细节但又不至于直接援引标准文档，且cppreference中给出了比标准文档更加人性化的解释。这里的”具体细节“包括返回的值到底是左值、右值，执行过程是否会创建临时变量，多级指针等内容。至于dynamic_cast的详细说明摘自C++ primer plus，说明了RTTI的简单使用。 定义部分。这部分翻译自C++标准文档，记录了对应运算符在标准的中的所有出现位置。 推荐阅读顺序 简要说明 运用实例：由简要说明部分跳转，或通过如下链接： 向上、向下转换 静态多态性 详细说明或标准定义：由简要说明部分跳转。 一些约定 在定义部分，所有页码无额外说明时指的是PDF页码，从封面开始编号，方便跳转。 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"brief-intro.html":{"url":"brief-intro.html","title":"简要说明","keywords":"","body":"类型转换运算符 简明介绍 主要参考资料： C++ Primer Plus 6th Edition C语言中文网 导入 C++兼容C大部分语法，这意味着C++中也能使用C语言风格的类型转换。即(type-name)var-name形式的强制类型转换。但这个转换在C++之父本贾尼·斯特劳斯特卢普看来是过于草率的。考虑如下代码片段： struct Data{ double data[200]; }; struct Junk{ int junk[100]; }; Data d = {2.5e33, 3.5e-19, 20.2e32}; char *pch = (char*)(&d); // 情况1 char ch = (char)&d; // 情况2 Junk *pj = (Junk*)(&d); // 情况3 上述代码没一个是有明确意义的，但上述转换对C语言都是合法可以编译的。为了消除这种草率的类型转换，C++引入了四种更加规范的类型转换方式： dynamic_cast const_cast static_cast reinterpret_cast C++更加推荐根据实际情况使用以上四种类型转换而不是使用通用类型转换，因为这能表现出类型转换的目的并让编译器有机会帮我们确认代码的行为与我们的预期相符。 dynamic_cast 目的 dynamic_cast运算符主要用于向下转化，也即使从基类类型到子类类型的转化。 向上转化时不常用dynamic_cast，因为大多数向上转化都是隐式进行的，完全没有必要使用任何类型转换运算符。 向下转化时也可以使用static_cast，但static_cast不会进行运行时检查，所以有一定风险。 假设有如下继承结构： // snippet: brief-intro-dyn-1.cpp, line 4-19. class Base { public: virtual void fun() { cout 考虑如下代码： // snippet: brief-intro-dyn-1.cpp, function run1. void run1() { Derived obj; Base* ptr = &obj; // after some complicated process // C style cast Derived* pd = (Derived*)ptr; pd->fun(); // output: Derived DDerived* pdd = (DDerived*)ptr; pdd->fun(); // Unexpected behavor pdd->bad(); // Runtime Error } 我们先创建一个Derived类型对象obj并用基类指针ptr指向它，经过一系列复杂的过程，甚至在该函数之外，我们想要把Base*类型指针向下转化为Derived*类型。这时如果我们头脑清醒，或者使用其他一些方法（比如添加一个获取类型描述字符串的方法）能够确定ptr指向的是一个Derived类型对象，那么我们当然可以直接使用C风格的类型转换，不会出现任何问题。上述代码第10行能正常执行。但如果程序非常复杂，我们不小心把ptr指向对象类型当成了DDerived，然后又进行C风格类型转换，编译器不会给出任何错误信息，甚至第13行代码都能够正确输出，直到14行，尝试修改一个a的值时才发生Runtime Error。这样的转换风险是极高的，说不定什么地方一个疏忽，就造成了一个隐蔽的bug。而此处正是dynamic_cast发挥作用的时候。 语法 dynamic_cast语法非常简单，指针形式语法如下： // pt is a pointer pointing to an object Type *pm = dynamic_cast(pt); 如果*pt实例是Type类型或者是其直接或间接公共继承的子类，上述语句将pt转化为一个Type*类型的指针，否则，返回nullptr。 现在使用如下转换代码： // snippet: brief-intro-dyn-1.cpp, function run2. void run2() { Derived obj; Base* ptr = &obj; // dynamic_cast Derived* pd = dynamic_cast(ptr); if (pd == nullptr) { cout fun(); DDerived* pdd = dynamic_cast(ptr); if (pdd == nullptr) { cout bad(); } 上述代码完美符合预期，即使我们写程序时忘记ptr指向对象的类型，我们也可以大胆使用dynamic_cast进行类型转化，转化成功皆大欢喜，转化失败也由nullptr指明，不会在代码中埋下难以预测的Bug，dynamic_cast的最大用处便在此处。 除了指针形式，dynamic_cast还有引用形式，语法如下： #include ... try{ // suppose rg is of type: TypeB& TypeA& ra = dynamic_cast(rg); }catch(bad_cast& e){ // handle failed cast } 使用上与指针形式基本没有区别，除了因为不存在空引用，所以当dynamic_cast转换失败时将抛出bad_cast异常。bad_cast继承自exception且在typeinfo头文件中定义(有趣的是我们很容易间接引入bad_cast，因为iostream头文件间接包含了bad_cast)。 使用限制 dynamic_cast有如下使用限制： 必须在存在虚函数表的继承体系中使用。理由如下： 如果没有继承体系那么完全不会出现向上、向下类型转换的需求。 dynamic_cast依托虚函数表进行工作，即要求至少存在一个虚函数。若转化类型缺失虚函数表，一般会编译失败，但也存在编译通过发生运行时错误的情况。 不能混用指针形式语法和引用形式语法。 转换目标必须是引用或者指针。 参考 详细说明 标准定义 摘要页 const_cast 目的 该类型转换运算符的目的单纯是为了改变指针或引用的const性和volatile性。 const_cast表达式的目的是偶尔我们会有修改一个大部分时间都是const变量的需求，在这种情况下，我们可以把这个变量声明为const的然后在需要修改的时候使用const_cast。当然我们可以使用C语言风格的类型转换，但使用const_cast总能在我们头脑发热时为我们检查一下，给出一些错误信息或者警告。 语法 const_cast的语法如下： const_cast(expression) 其中type-name和expression除了cv-qualifier之外必须是同一个指针或引用类型，如果条件不满足，一般来说编译器会报错。 例如： // snippet: brief-intro-con-1.cpp, line 4-13. // Low 是 High 的基类 High bar; const High *pBar = &bar; // ... High *pb = const_cast(pbar); // valid const Low * pl = const_cast (pBar); // invalid 第一个转换得到一个可以用来修改bar对象的指针pb，const的限定被移除掉了。第二是转换是非法的，因为它尝试从const High*转化到const Low*。 使用限制 但是const_cast对const性的移除也不是非常强大，在使用时甚至会有一些未定义行为。const_cast允许我们修改一个指针对一个量的可访问性，但修改一个被声明为const的量的值是一个未定义行为，例如下述代码。 // snippet: brief-intro-con-1.cpp void change(const int* p, int d) { int* pc = const_cast(p); *pc += d; } void run2() { int valA = 100; const int valB = 100; int *pB = const_cast(&valB); cout 在change中，因为const_cast移除了pt的const性，所以编译器允许*pc += n;语句的存在。我们预期的输出大多是这样的： 100 100 120 120 *pB = 120 但在MSVC、g++、clang编译运行结果： 100 100 120 100 *pB = 120 这下代码就迷惑起来了，valB荣获矛盾文学奖，它变了，但又没变。这样的输出是因为编译器会吧const的在编译器就翻译为了它的值，也就是说valB在编译时就变成了100，所以运行时修改了他的值输出也不会体现出来。但以上解释都是瞎说，在ISO C++定义中明确表示这样的代码导致未定义行为，虽然主流编译器下通过指针访问都得到了我们期待的值，但最好不要出现这样的代码。 注：这个例子来自C++ Primer Plus，但书中的解释有些小问题，编译器并没有保护const int的值不被改变，通过指针访问可以说明这一问题。 参考 详细说明 标准定义 摘要页 static_cast 目的 用来进行编译器可以进行的隐式转换，但不能修改变量的cv修饰符。 注：C语言中文网中说static_cast是在编译期进行的转换，这句话多半有误，因为static_cast可能会调用构造函数等函数，这些函数都是在运行时执行的，所以static_cast并不意味着在编译时进行转换。 语法 static_cast(expression); 上述转换只有在从expression到type-name存在一系列的隐式转换、或存在反方向的一系列隐式转换、或有用户自定义转换存在时，这个语句才是合法的。假设High是Low的基类，Pond是与两者无关的类，那么从High到Low或反方向转换时可行的，但不允许从Low到Pond的转换。 注：上述描述其实也不太准确，准确的定义见ISO static_cast //snippet: brief-intro-static-1.cpp High bar; Low blow; High * pb = static_cast(&blow); // 正确：向上转型 Low * p1 = static_cast(&bar); // 正确：向下转型 Pond * pmer = static_cast(&blow); // 编译错误 第一个转换是向上转型，可以隐式进行，所以是合法的。第二个转换是向下转换，必须显示转换，但因为其逆向的转换是合法的，所以也能使用static_cast。 相似的，如下转换也能进行： 因为一个枚举类型的值可以被隐式地转换为整形，所以一个整形可以使用static_cast转换为枚举类型。 进行一些列数值类型的转换，例如：double到int、float到long等。 void类型指针与具体指针类型之间的转换，例如：void*转int*，char*转void*等。但static_cast不能直接在两个具体指针类型之间转换，例如从int*到char*。也不能直接把一个整型转换为指针。 如果存在自定义的转换运算符或转换构造函数，也能使用static_cast进行转换，此时会调用这些转换\\构造函数，例如： //snippet: brief-intro-static-2.cpp struct vector {int a, b;}; class Complex{ public: int real = 0, imag = 0; Complex(){} Complex(vector &v) { real = v.a; imag = v.b; cout (v); // 调用了Complex的构造函数 cout (c); // 调用了Complex的转换运算符 cout 输出为： Constructor real: 1 imag: 2 Type conversion operator. len ^ 2 = 5 使用限制 不能修改cv修饰符 向下转换时不会进行类型检查，可能造成运行时错误。例如： //snippet: brief-intro-static-1.cpp struct High { int a = 10; }; struct Low : High { int b = 20; }; int main(){ High bar; Low * p1 = static_cast(&bar); cout b ... 见ISO_static_cast 参考 详细说明 标准定义 摘要页 reinterpret_cast 目的 reinterpret_cast将会进行一些具有极大风险性的类型转换。虽然这个运算符不能去除常量性，但它允许一些极其怪异的转换。有时一个程序需要做一些依赖于实现的事情，此时使用reinterpret_cast可以简化这些操作。 语法 reinterpret_cast(expression); reinterpret_cast进行转换时仅仅是对数据二进制位的重新解释，一般不会借助转换规则来调整对象。 使用示例： //snippet: brief-intro-rpt-1.cpp struct dat {short a; short b;}; long value = 0xA224B118; dat *pd = reinterpret_cast(&value); cout a; // 输出 value 的前两个字节的数据 一般来说，reinterpret_cast会用于底层的、实现依赖的不可迁移程序。就连上述的例子在小端机和大端机上的行为都不同。例如在作者的操作系统下，输出为b118，说明我的机器为小端机，但在其他的电脑上有可能输出为A224。 使用限制 把一个指针转换为一个整型时，这个整型需要足够大，保证能储存指针的值。 不能把指针转换为浮点类型。 不能把函数指针转换为普通的指向数据类型的指针。 不要尝试在继承体系中使用reinterpret_cast，例如： //snippet: brief-intro-rpt-2.cpp struct A {int a;}; struct B {int b;}; struct C : A, B {}; ... cout (&c) (&c) 某次运行结果： 0097FC20 0097FC24 0097FC20 向上转换时static_cast正确地偏移了指针，但是reinterpret_cast没有。注：这里也不能使用dynamic_cast因为没有虚函数表。 参考 详细说明 标准定义 摘要页 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"dynamic_cast.html":{"url":"dynamic_cast.html","title":"dynamic_cast.md","keywords":"","body":"dynamic_cast详细描述 Ref: C++ Primer Plus Chapter 15. Friends, Exceptions, and More Runtime Type identification 引入目的：RTTI RTTI: Runtime type identification，运行时类型检测 目的：The intent of RTTI is to provide a standard way for a program to determine the type of object during runtime. RTTI如何工作： 由三个部分支撑： dynamic_cast运算符：如果可能dynamic_cast将一个指向基类类型的指针转化为指向子类类型的指针。如果这种装换无法完成，返回nullptr。 typeid运算符：返回描述一个实例的类型的值 type_info结构体：描述某个类型的信息 注：只能将RTTI用于拥有虚函数的继承体系。理由：只有在拥有虚函数的继承体系下，将子类实例的地址赋给基类指针才是有意义的。且RTTI依托虚函数表工作。 dynamic_cast运算符 虽然该dynamic_cast不会告诉我们一个指针指向的实例的类型，但它会回答是否能安全地将一个实例的地址赋给某个类型的指针的问题。值得注意的是，“判断一个类型转换是否安全”比“精确获取实例类型”更为广泛和有用。因为我们希望获取实例类型的原因在于我们想知道调用一个函数是不是可行的。 指针形式 语法： // pt is a pointer pointing to an object Type *pm = dynamic_cast(pt); 如果*pt实例是Type类型或者是其直接或间接公共继承的子类，上述语句将pt转化为一个Type*类型的指针，否则，返回nullptr。 dynamic_cast主要用于向下转型，即：从基类到子类的类型转换。 注：只有在拥有虚函数继承体系中才能使用dynamic_cast，因为dynamic_cast依赖虚函数表工作。 例如下述代码会报错(msvc编译)：E0698：运行时 dynamic_cast 的操作数必须包含多态类型 //snippet: dyn-cast-ex1.cpp class Base {}; class Sub : public Base {}; //main Base* pSub = new Sub; Sub* pCast = dynamic_cast(pSub); // E0698 在拥有虚函数的继承体系，更进一步，指的是dynamic_cast的目标、源都需要具有虚函数表，否侧dynamic_cast不会正常工作。例如： //snippet: dyn-cast-ex2.cpp class Base { public: virtual void fun() {} }; class Sub : public Base {}; class BadGuy {}; //main BadGuy* pB = new BadGuy; Base* pD = dynamic_cast(pB); // E0698 但上述代码第6行若改为 //snippet: dyn-cast-ex3.cpp class BadGuy { public: virtual void bad(){} }; 编译时不会提示任何错误，运行时dynamic_cast(pB);的值为nullptr，符合我们的预期。 虽然有这些比较麻烦的设置，但情况还不是非常严峻，编译器能够给我们非常确切的提示。 但如果将reinterpret_cast也牵扯进来，事情就复杂起来了，见如下代码： //snippet: dyn-cast-ex4.cpp class Base { public: virtual void fun() {} }; class Sub : public Base {}; class NotThatBad { public: virtual void fun() {} }; class BadGuy {}; //main // case 1 NotThatBad* pNTB = new NotThatBad; Base* pBase1 = reinterpret_cast(pNTB); Sub* pSub1 = dynamic_cast(pBase1); //pSub1 = nullptr // case 2 BadGuy* pBad = new BadGuy; Base* pBase2 = reinterpret_cast(pBad); Sub* pSub2 = dynamic_cast(pBase2); // Runtime Error case 1虽然进行了危险reinterpret_cast跨继承进行转换，但是dynamic_cast仍然正常执行了，毕竟NotThatBad类型实例具有虚函数表，能支持dynamic_cast的工作。 但case 2在运行时出现内存错误，这是因为BadGuy类型实例不具备虚函数表，当dynamic_cast尝试通过虚函数表获取实例的类型时便触发内存错误。 引用形式 dynamic_cast也可以作用于引用，与指针形式稍有区别，因为不存在空的引用，所以当dynamic_cast转换失败时将抛出bad_cast异常。 bad_cast继承自exception且在typeinfo头文件中定义(有趣的是我们很容易间接引入bad_cast，因为iostream头文件间接包含了bad_cast)。 参考代码如下： #include ... try{ // suppose rg is of type: TypeB& TypeA& ra = dynamic_cast(rg); }catch(bad_cast& ){ } 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"const_cast.html":{"url":"const_cast.html","title":"const_cast.md","keywords":"","body":"const_cast 详细说明 Ref: cpp reference, const_cast 语法 const_cast(expression) 返回类型为new_type 解释 背景术语 cv-qualifer：译为 cv 修饰符，指的是声明变量时在类型前或变量名前的const或volatile修饰符。例如： const int a = 10; const int* const c; volatile int b; 多级指针：在本文中为指向指针的指针或者更深的指针结构，例如int *****b;是一个5级指针。 左值、右值、纯右值、泛左值、消亡值：参见微软文档的解释 说明 const_cast被用于移除cv-qualifier。 只有下述转换可以使用const_cast完成： 对于两个指向同一类型的多级指针，尽管每一级的cv-qualifier可能有所不同，但二者可以相互转换。 类型T的左值可以被转换为T类型的具有不同cv-qualifier的左值引用或右值引用。类似的，同一个类型的纯右值以及任意消亡值可以被转化为具有不同 cv 修饰符的右值引用，如果expression是一个泛左值，则const_cast结果指向原来的对象；其他情况下const_cast结果指向被实例化的临时区（materialized temporary）。 上述规则同样适用于指向成员变量或者数组的多级指针。 空指针可以被转换成new_type类型的空指针。 转换结果满足： 如果new_type是对一个对象的右值引用，则结果为消亡值。 其他情况下，结果为纯右值。 注： const_cast不适用于指向函数的指针和指向成员函数的指针 const_cast可能会把一个指向常量值的常量指针转化为普通指针，但转化后的指针指向的还是那个常量值，此时通过转换后的指针修改常量的值是一个未定义行为。该情况也适用于引用形式和volatile属性。 示例 例1 基本使用 // snippet: const_cast-ex1.cpp #include using namespace std; struct type{ int i; type(): i(3){} void f(int v) const { // this->i = v; // 编译错误，this是指向常量的指针 const_cast(this)->i = v; // 可能出现未定义行为 } }; int main(){ int i = 3; const int& rci = i; const_cast rci = 4; // 正确：i = 4 cout (&j); *pj = 4; // 未定义行为，主流编译器下j的值不会有任何改变 cout (pmf); // 编译错误：const_cast不适用于函数指针 return 0; } 输出： i=4 type::i=4 j=3 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"static_cast.html":{"url":"static_cast.html","title":"static_cast.md","keywords":"","body":"static_cast 详细说明 Ref: https://en.cppreference.com/w/cpp/language/static_cast 功能 通过一系列隐式转换或者用户自定义转换执行类型转换。 Syntax static_cast(expression) 返回new_type的值。 功能细节 只有下述转换在不涉及cv修饰符更改时可以使用static_cast完成： 如果存在从expression到new_type的一些列隐式转换，或者new_type至少重载一个函数能直接从expression的值或引用初始化这个new_type类型，那么static_cast返回一个假想的如同使用new_type Temp(expression)构造的Temp对象。这可能会涉及到隐式类型转换，new_type的构造函数或是用户自定义类型转换运算符。对于非引用类型的new_type，对纯右值expression类型的转化对象即是直接初始化的对象。 如果new_type是某个D类型的引用或者指针，且expression是它的非虚基类B或是指向它的纯右值指针，static_cast会执行一个向下转换（当B有歧义的、不可访问、D的虚基类、D的虚基类的基类时，这个向下转化是非规范的）。这种向下转换不会进行运行时检查来确保这个对象的类型确实是D，所以此时的向下转换只能安全地用于上述条件能被其他方法保证时，例如静态多态性。安全的向下转换可以使用dynamic_cast。 struct B{}; struct D : B {}; D d; B& br = d; static_cast(br); // 表示原来的d对象的左值。 如果new_type是右值引用类型，static_cast会把泛左值、类类型纯右值、数组类型纯右值、任何左值类型的expression转换为代表原对象的消亡值，或原对象的基类子对象。如果目标类型是expression的不可访问或有歧义基类，该程序是非规范的。如果expression是一个位域(bit field)类型左值，会先转化为底层类型的纯右值。std::move移动语义就是用static_cast实现。 如果new_type是void类型，static_cast会在对expression求值后直接抛弃这个值。 如果存在一个从new_type到expression的标准转换(standard conversion)链，且这个转换中不包含左值到右值、数组到指针、函数到指针、空指针、空成员指针、函数指针和布尔转换，则static_cast也能进行逆向的隐式转换。 如果一个从expression到new_type涉及到左值到右值、数组到指针、函数到指针的转换，这个转换可以显式地通过static_cast完成。 限域枚举类型可以被转换为整型或浮点型。 当目标类型为bool，expression值为0时转化结果为false，为其他值时结果为true。对于其他的整型类型，如果它能被目标类型表示，则转换结果是枚举的值，否则是未指明的。(C++20 之前) 转化结果同从枚举的底层类型到目标类型的隐式转换结果相同。 (C++20 开始) 一个指针或者枚举的值可以被转换为任何完整的枚举类型。 如果底层类型未指定，如果expression的值超出了目标类型可以储存的范围，转化结果是未定义的。 如果底层类型确定，转化过程可以视为先把expression枚举的底层类型，然后再转换为枚举类型。 一个浮点类型的值也可以被转换为任意完成的枚举类型。 转化过程可以视为先把expression枚举的底层类型，然后再转换为枚举类型。 一个类D的成员指针可以被向上转换为他的无歧义、可访问基类B的成员指针。此时static_cast不会进行运行时检查来保证在运行时指向的成员确实存在。 一个void*的纯右值指针可以被转换为任意类型指针。如果原指针的值代表的内存地址不满足目标类型的内存对齐条件，那么转化结果是不确定的。否则，如果原指针指向对象a，且存在一个和a是指针可互换的(pointer-interconvertible)目标类型的对象b，转化结果是指向b的指针。否则，指针的值不会被改变。所有将一个指针转化为void*类型再转化为原类型的转换会保留指针原有的值。 对于所有的上述转换，转换结果满足： 如果new_type是代表函数的左值引用或右值引用类型，则结果是左值。 如果new_type是对象的右值引用，则结果是消亡值。 其他情况下，结果是纯右值。 如果满足下述条件，则两个对象a、b是指针可互换的： 他们是同一个对象；或者 一个是联合体类型（union）且另一个是那个对象的非静态数据成员；或 一个是标准结构类型(standard-layout class)对象，另一个是那个对象的第一个非静态数据成员，或如果该对象不具有非静态数据成员、任何基类类型的子对象；或 存在一个对象c是的a和c是指针可互换的且c和b是指针可互换的 例如： union U {int a; double b;} u; void* x = &u; // x 是 “指向u的指针” double* y = static_cast(x); // y 是 “指向u.b的指针” char* z = static_cast(x); // z 是 “指向u”的指针 注： static_cast也可以通过执行一个函数到指针的转换来消除函数重载的模糊性，例如： std::for_each(files.begin(), files.end(), static_cast(std::flush)); 例 #include #include struct B { int m = 0; void hello() const { std::cout (3.14); std::cout v = static_cast>(10); std::cout (br); // 向下转换 another_d.hello(); // 3: 左值转化为右值 std::vector v2 = static_cast&&>(v); std::cout (v2.size()); // 5. 隐式转换逆转换 void* nv = &n; int* ni = static_cast(nv); std::cout (a); // 7. 限域枚举转换为int或float E e = E::ONE; int one = static_cast(e); std::cout (one); EU eu = static_cast(e2); // 9. 对成员指针进行向上转换 int D::*pm = &D::m; std::cout (pm) * p = static_cast*>(voidp); } Output： n = 3 v.size() = 10 Hello world, this is B! Hello world, this is D! after move, v.size() = 0 *ni = 3 1 0 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"reinterpret_cast.html":{"url":"reinterpret_cast.html","title":"reinterpret_cast.md","keywords":"","body":"reinterpret_cast 详细说明 reinterpret_cast仅仅是对二进制位的重新解释，不会对数据进行调整，风险较高。 Ref: cpp reference reinterpret_cast 语法 reinterpret_cast(expression) 返回new_type类型的一个值。 解释 规则列表 与static_cast不同，reinterpret_cast除了在进行整型和指针或者在指针表示依赖于类型的糟糕的系统架构上，不会被编译为任何CPU指令。这仅仅是一个编译期指令，让编译器把expression的类型当成new_type处理。 仅有下述转换可以通过reinterpret_cast实现，且reinterpret_cast不能去除任何常量性(constness)和易变性(volatility)。 一个整型、枚举型、指针、成员指针类型的表达式可以被转换为自己的类型。转换结果的值就是表达式的值。 指针可以被转换为任意足够大的能容纳指针值的整型类型。 任何整型或者枚举类型可以被转换为指针类型。可以保证一个指针转换成足够大整型后再转换回原类型指针的值就是原有的值，否则转换结果指针不能被安全地解引用（该保证不包括另一个方向的回环转换；相同的指针也许会有不同的整型表示）。空指针常量NULL或0值整型不保证一定能转换成目标类型的空指针，此时应该使用static_cast或者隐式转换。 std::nullptr_t类型的任何值，以及值nullptr，可以被转换成任意整型类型，就像是转换的是没有值的(void)*0一样，甚至nullptr也不能被转换为std::nullptr_t，这样的转换应该使用static_cast实现。 任意T1*类型指针可以转换为cv T2*类型指针。这完全等价为： static_cast(static_cast(expression)) 此时T2的内存对齐要求不比T1严格，指针的值保持不变，且将转换结果再转换成原类型其值也保持原指针的值。 在任何情况下，只有在满足类型别名规则(type aliasing rules)时，结果指针才能被安全地解引用。 任何T1类型的左值引用可以转换为T2类型的右值引用。转换结果是指向原对象的一个不同类型的左值或消亡值。这个过程不会创建临时变量、不会进行拷贝、不会调用构造函数或转换函数。只有在满足类型别名规则时，对结果引用的访问才是安全的。 任何指向函数的指针可以被转换成指向另一个函数类型的指针。通过另一个函数类型的指针调用该函数的行为是未定义的，但将转换结果指针再转换回原函数指针类型将得到指向原来函数的指针。 在一些操作系统实现下（特别是兼容dlsym的POSIX系统中），一个函数指针可以被转换为void*类型或者任何其他对象类型指针，反方向亦然。如果该操作系统支持双向转换，把结果转换成原类型将得到最初的值，除此之外结果指针不能被安全地调用或解引用。 任指针类型的空指针可以被转换问任意其他指针类型，结果就是目标类型的空指针。注意空指针常量nullptr或std::nullptr_t类型的任意值不能使用reinterpret_cast转化为其他指针，这种转换应该使用隐式转换或者static_cast。 一个指向成员函数的指针可以转换为指向另一个不同类型的成员函数的指针。再把它转换回原类型将得到最初的值，否则结果指针不能被安全地使用。 一个指向某个类T的成员对象的指针可以转换为指向另一个类T2的成员对象的指针。如果T2对齐要求不比T1严格，则再将指针转化回原T1类型将得到最初的值，否则转换结果对象无法被安全地使用。 对于所有的reinterpret_cast，结果满足： 如果new_type是左值引用类型或对函数类型的右值引用，结果为左值。 如果new_type是对对象的右值引用类型，结果为消亡值。 其他情况下结果为纯右值。 类型别名 尝试通过类型AliasedType的泛左值读取或修改DynamicType类型对象的值将产生未定义行为，除非下述规则之一满足： AlisedType和DynamicType是相似的。 AlisedType是DynamicType的有符号或无符号变体。 AlisedType是std::byte、char或unsigned char。该规则运行把任何对象当成字节数组来检查该对象的表示(object representation)。 类型相似 不太严谨的说，忽略最高层级的cv限定符，两个类型是相似的，如果： 他们是同一个类型；或 他们都是指针，且指向的类型相同；或 都是指向同一个类的成员指针，且指向的成员是相似的；或 都是相同大小的数组或都是未知边界的数组，且数组元素类型相似；或 (until C++20) 都是相同大小的数组或二者中至少有一个是未知边界的数组，且元素类型相似。 例如： const int * volatile *和int * * const是相似的 const int (* volatile S::* const)[20] 和int (* const S::* volatile)[20] 是相似的 int (* const *)(int *) 和int (* volatile *)(int *)是相似的 int (S::*)() const 和int (S::*)() 不相似。 int (*)(int *) 和int (*)(const int *) 不相似; const int (*)(int *) 和int (*)(int *) 不相似; int (*)(int * const) 和int (*)(int *) 相似; std::pair 和std::pair 不相似； 这个规则支持了类型别名分析，这里编译器假设通过一个类型的泛左值读取数据不会因通过另一种类型的泛左值写入数据遭到修改。 注1：许多C++编译器会引入非标准语言拓展来放松上述规则，使通过共同体的不活动成员访问错误的类型。 注2：标准中上述规则还包括从C语言继承而来的两点额外规则，但下述情况可能在C++中出现，所以被忽略掉了。 AliasedType是一个聚合体类型(aggregate type)或是共同体类型，且该类型包含上述提到类型之一作为一个元素或非静态成员（递归地包括子聚合体和包含共同体的非静态数据成员） AliasedType是DynamicType的基类。 代码示例 基本使用 //snippet: rpt-cast-ex1.cpp #include #include #include int f() { return 42; } int main() { int i = 7; // 指针与整型间相互转换 std::uintptr_t v1 = reinterpret_cast(&i); // 使用 static_cast 将导致编译错误 std::cout (v1); assert(p1 == &i); // 函数指针间的转换 void(*fp1)() = reinterpret_cast(f); // fp1(); undefined behavior int(*fp2)() = reinterpret_cast(fp1); std::cout (&i); if(p2[0] == '\\x7') std::cout (i) = 42; std::cout (const_iref); //编译错误 - 无法去除const //此时必须使用const_cast: int &iref = const_cast(const_iref); } 一种可能的输出： The value of &i is 0x7fff352c3580 42 This system is little-endian 42 指针可交换 假设满足内存对齐要求，reinterpret_cast不会改变指针的值，除了一些指针可互换的情况： struct S1 { int a; } s1; struct S2 { int a; private: int b; } s2; // S2 不是标准布局类型 union U { int a; double b; } u = {0}; int arr[2]; int* p1 = reinterpret_cast(&s1); // p1 的值是 \"指向s1.a的指针的值\"因为 s1.a 和 s1 是指针可互换的 int* p2 = reinterpret_cast(&s2); // p2 的值不会改变，就是“指向s2的指针的值” int* p3 = reinterpret_cast(&u); // p3 的值是 “指向u.a的指针的值”。u.a 和 u 是指针可互换的。 double* p4 = reinterpret_cast(p3); // p4 的值是 “指向u.b” 的值。u.a 和 u.b 也是指针可互换的， //因为他们与 u 是指针可互换的。 int* p5 = reinterpret_cast(&arr); // p5 值保持不变，就是“指向arr的指针” 未定义行为情况 对一个泛左值访问一个类型的非静态成员数据或非静态成员函数，但这个泛左值恰好不是这个类型时，将导致未定义行为： struct S { int x; }; struct T { int x; int f(); }; struct S1 : S {}; // 标准布局 struct ST : S, T {}; // 非标准布局 S s = {}; auto p = reinterpret_cast(&s); // p 是 \"指向s的指针\" auto i = p->x; // 未定义行为：s 不是一个 T 类型对象 p->x = 1; // 未定义行为 p->f(); // 同上 S1 s1 = {}; auto p1 = reinterpret_cast(&s1); // p1 是 \"指向 s1 的 S类型子对象的指针\" auto i = p1->x; // 程序正确 p1->x = 1; // 正确 ST st = {}; auto p2 = reinterpret_cast(&st); // p2 是 \"指向 st 的指针\" auto i = p2->x; // 未定义行为 p2->x = 1; // 未定义行为 即使理论上说这些代码违背了前文提到的严格别名规则，许多编译器只会对这些情况报出“strict aliasing”的警告；有些编译器甚至不会有任何警告，例如：clang编译器。 严格别名规则以及相关规则的目的是启用基于类型的别名分析(type-based alias analysis)，但当一个程序使两个毫无关联的类型的指针(如float*和double*)同时用于访问同一块内存时该机制极易被破坏。所以，任何有可能造成上述情况的技术比然造成未定义行为。 与std::memcpy、std::bit_cast(since C++ 20)结合 但需要把一个对象的字节解释为另一个类型时，可以考虑使用std::memcpy、std::bit_cast(since C++ 20)。 double d = 0.1; std::int64_t n; static_assert(sizeof n == sizeof d); // n = *reinterpret_cast(&d); // 未定义行为 std::memcpy(&n, &d, sizeof d); // OK n = std::bit_cast(d); // also OK 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"ISO_dynamic_cast.html":{"url":"ISO_dynamic_cast.html","title":"ISO dynamic_cast.md","keywords":"","body":"ISO 14882 对dynamic_cast的描述 定义部分 P125 8.2.7 Dynamic cast 表达式(expression)dynamic_cast(v)的结果是将表达式v转化为类型(type)T。T应该是指向一个完整类型(complete class type)的指针或者引用，或者是可能有const和violate修饰的void类型指针(pointer to cv void)。dynamic_cast不会擦除常量性(constness)。 如果T是指针类型，则v应该是一个指向完整类型的纯右值(prvalue)指针，且转化结果是类型为T的纯右值变量。如果T是左值引用(lvalue reference)类型，则v应该是一个完整类型的左值(lvalue)，且转化结果是由T指定类型的左值。如果T是右值引用(rvalue reference)类型，则v应该是拥有完整类型的泛左值，且转化结果是由T指定类型的消亡值(xvalue)。 如果v的类型和T类型相同，或仅T的类型比v的类型多了cv限定符(cv-qualifier)，转化结果为v。(如果必要将进行转换) 如果v的是指针且为空指针(null pointer)，转化结果为T类型的空指针。 假设T为pointer to cv1 B(cv1 B类型的指针)，v类型为pointer to cv2 D(cv2 D类型的指针)，其中B是D的基类，cv1、cv2表示不同的两个cv限定符，转化结果为指向由v指向的D对象的唯一B类型子对象的指针。相似的，如果T是cv1 B类型的引用，v类型为cv2 D，其中B是D的基类，转化结果为由v指定的D对象的唯一B类型对象的引用。在上述两个情况中，如果cv2限制等级比cv1高或者B是D的不可访问或有歧义基类，这部分代码是不规范的(ill-formed)。例如： struct B{}; struct D:B{}; void foo(D* dp){ B* bp = dynamic_cast(dp); // equivalent to B* bp = dp; } 译注： 这里需要区分子类和子对象的区别。类是 class type 是一种静态结构，用于描述对象中储存数据的结构和行为；对象是 object 是类在内存中的具体表示，是动态可变的。 从静态结构上看，子类包含父类所有功能，即 子类 ⊃\\supset⊃父类。 从内存上看，一个对象的子对象是该对象内存中的一部分，也即是 子对象 ⊂\\subset⊂ 对象。 除上述限制外，v应该是一个指向多态类型(polymorphic type)的指针或多态类型的泛左值。 如果T是void类型的指针(无论是否有cv限定符)，则转化结果指向v指向的对象，且类型为v对象的最大派生对象(most derived object pointed to by v)。除此之外，dynamic_cast会在运行时(runtime)检测指针或引用v代表的对象能否转化为T确定的指针类型或引用类型。 如果C是T指向或引用的类型，运行时检测按照下述逻辑执行： 如果在v指向(引用到)的最大派生对象中，v指向(引用至)一个C对象的公共基类字对象(a public base class subobject of a C object)，且仅当v指向的子对象只派生出唯一的C类型对象，则转化结果指向(引用至)那个C对象。 除上述情况，如果v指向(引用至)最大派生对象的一个公共基类对象，并且最大派生对象拥有一个无歧义公共C类型基类，转化结果指向(引用至)最大派生对象的C类型字对象。 除上述情况，转化失败。 关于指针的失败转化的结果是一个转化目标类型的空指针。一个失败的对引用的转化将会抛出std::bad_cast类型的异常。例： class A {virtual void f();} class B {virtual void g();} class D : public virtual A, private B {}; void foo(){ D d; B* bp = (B*)&d; // 需要强制转换来打破访问保护 A* ap = &d; // 公有继承，不需要装换 D& dr = dynamic_cast(*bp); // 失败，bp指向的对象类型为B，bp指向的最大派生对象类型为D，bp指向对象是D的私有基类类型，不满足 8.a 条件。 ap = dynamic_cast(bp); // 失败，原因基本同上，B是D的私有基类 bp = dynamic_cast(ap); // 失败，同上 ap = dynamic_cast(&d); // 成功 bp = dynamic_cast(&d); // 非规范行为，无运行时检测。 } class E : public D, public B {}; class F : public E, public D {}; void bar(){ F f; A* ap = &f; // 成功 D* dp = dynamic_cast(ap); // 失败，f具有两个D子对象 E* ep1 = dynamic_cast(ap); // 成功 E* ep = (E*)ap; // 非规范行为：从虚基类转换 } 译注：可结合下述继承关系图理解： 注：15.7描述了类还在构造时dynamic_cast的行为。 其余涉及到dynamic_cast的说明 P40 5.11 Keywords dynamic_cast是保留关键词之一。 P55 6.2 One-definition rule 条目 5.6 大概意思是dynamic_cast中出现的类型需要有完整定义。 P87 6.8 Object lifetime 条目 6.8，条目 7.4 说明在对象的生命周期已经开始但所需内存还未分配或对象生命已经结束但所占内存还未释放时，使用dynamic_cast会出现未定义行为(undefined behavior)。 P121 条目 1、条目 2 说明dynamic_cast是从左到右结合的后缀表达式(postfix-expression)。 在dynamic_cast语境下，>>被理解为两个>而不是右移符号。 P8.4 Explicit type conversion (cast notation) 条目2 说明显示类型转换(explicit type conversion)可以用函数式记号(functional notation)、类型转换运算符(dynamic/static/const/reinterpret_cast)或强制装换运算符(cast notation)。 P308 Initializing bases and members 条目 17 说明在15.7描述了在构造期间调用虚函数(virtual function)、typeid和dynamic_cast时有良定义(well-defined)的情况，即描述构造期间对象的多态行为。 P312 15.7 Construction and destruction 条目 5 在对象构造和析构的时候也可以调用dynamic_cast。当dynamic_cast在构造函数(包括成员构造函数(mem-initializer)或非静态数据成员(non-static data member)的默认成员构造函数(default member initializer))、析构函数、或从一个构造函数或析构函数中间接或直接地被调用时，如果dynamic_cast的操作数指向(引用至)的对象正在被构造或者析构，这个对象的最大派生对象的类型被视为正在构造或析构的构造函数或析构函数所在类的类型。如果操作数指向的正在构造或析构的对象的静态类型(static type)不是指向构造函数或析构函数所在类型本身或其基类，则dynamic_cast的对过是未定义的。例： struct V {virtual void f();}; struct A : virtual V {}; struct B : virtual V {B(V*, A*);} struct D : A, B { D(): B((A*)this, this) {} } B::B(V* v, A* a){ typeid(*this); // B 的 type_info typeid(*v); // 良定义：*v的类型为V，B的一个基返回的是B的type_info typeid(*a); // 未定义：A不是B的一个基类 dynamic_cast(v);// 良定义：v类型为V*，V是B的基类，结果类型为B* dyanmic_cast(a);// 未定义：a类型为A*，A不是B的基类 } 继承关系图： P396 17.6.2.2 Type-dependent expression 条目 3.8 说明包含dynamic_cast的id-expression是类型依赖(type-dependent)的。 P435 18.1 Throwing an exception 条目 1 说明dynamic_cast可能会抛出异常。 P440 18.4 Exception specifications 条目 6.4 说明dynamic_cast可能会抛出异常。 P513 21.7.3 Class bad_cast 条目 1 说明bad_cast用于报告失败的dynamic_cast P518 21.8.7 nested_exception 条目 2、条目 9 说明可以用dynamic_cast带检测nested_cast的多态性 对rethrow_if_nested的进一步说明 P522 21.10.4 Signal handlers 条目 3 说明dynamic_cast是信号安全的(singal-safe) P639 23.11.2.2.9 shared_ptr cast 条目 4、条目 5.1 shared_ptr的成员函数中使用到了dynamic_cast，此时要求dynamic_cast相关语句是良定义且规范(well formed)的。且在实现上另一种等价语句将导致未定义行为。 P648 23.12.2.2 memory_resource private virtual member functions 条目 7 某一个接口返回值的定义依赖于dynamic_cast P655 23.12.5.4 Pool resource members 条目 9、条目 10 在线程安全的内存池的实现中使用到了dynamic_cast。 P657 23.12.6.2 monotonic_buffer_resource members 条目 10 方法实现时使用了dynamic_cast语句。 其余的琐碎的涉及： P1427 出现在附录A Grammar summary 中 P1527 出现在索引(Index)中 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"ISO_const_cast.html":{"url":"ISO_const_cast.html","title":"ISO const_cast.md","keywords":"","body":"ISO const_cast ISO/IEC 14882 中对const_cast的描述 对const_cast的定义 P131 8.2.11 Const cast 表达式cast_cast(v)的结果的类型是 T。如果T是一个对象的左值引用，结果是一个左值；如果T是一个对象的右值引用，结果是一个消亡值；除上述情况外，结果是一个纯右值且会对v执行从左值到右值、从数组到指针或从函数到指针的标准转换。仅有下述列出的转换可以通过显示调用const_cast完成。 注：对于本小节，一个表达式可以使用const_cast转换为表达式本身的类型。 对于两个相似(similar)的类型T1、T2，T1的一个纯右值可以使用const_cast显式地转换为T2。其结果指向原来的实体(entity)。例： typedef int *A[3]; // 指向int的长度为3的指针数组 typedef const int *const CA[3]; // 指向const int的长度为3的常量指针数组 CA &&r = A{}; // 正确，在限定符转换后引用绑定到CA类型的临时数组对象上 A &&r1 = const_cast(CA{}); // 错误：临时数组退化为指针 A &&r2 = const_cast(CA{}); // 正确 译注：相似的类型，指经过限定符分解后，指针层数一致且基本类型一致的两个类型。即，两个多级指针仅仅某些层上的cv修饰符有区别。该概念定义在 标准7.5 Qualification conversions中。 对于两个类型分别为T1和T2的对象， 如果一个指向T1的指针可以使用const_cast显式转换为指向T2的指针，那么也可以使用执行下述转换： 使用const_cast把一个T1的左值转换为T2的左值。 使用const_cast把一个T1的泛左值转换为一个T2的消亡值。 如果T1是一个类类型(class type)，可以使用const_cast把T1的纯右值转换为T2的消亡值。 上述转换结果都会引用至原对象，或者是在v是泛左值的情况下引用至采用临时变量具体化转换(temporary materialization conversion)后的对象。 空指针将会转化为目标类型的空指针，对于成员指针(pointer to member)同理。 注：依赖于具体的对象类型，对通过使用const_cast去除const限定得到的指针或引用进行写操作可能会导致未定义行为。 如果T1和T2不同，T1的cv分解(cv-decomposition, 7.5 Qualification conversions)导出 n 使得T2具有形如： ​ cv02  P02  cv12  P12 ⋯ cvn−12  Pn−12  cvn2  U2cv_0^2\\ \\ P_0^2\\ \\ cv_1^2\\ \\ P_1^2\\ \\cdots\\ cv_{n-1}^2\\ \\ P_{n-1}^2\\ \\ cv_n^2\\ \\ U_2cv​0​2​​  P​0​2​​  cv​1​2​​  P​1​2​​ ⋯ cv​n−1​2​​  P​n−1​2​​  cv​n​2​​  U​2​​ 的cv分解，且不具备能将T1转换为 ​ cv02  P01  cv12  P11 ⋯ cvn−12  Pn−11  cvn2  U1cv_0^2\\ \\ P_0^1\\ \\ cv_1^2\\ \\ P_1^1\\ \\cdots\\ cv_{n-1}^2\\ \\ P_{n-1}^1\\ \\ cv_n^2\\ \\ U_1cv​0​2​​  P​0​1​​  cv​1​2​​  P​1​1​​ ⋯ cv​n−1​2​​  P​n−1​1​​  cv​n​2​​  U​1​​ 的限定符转换，使用const_cast将T1转换为T2会去除常量性。 译注：参考 stackoverflow: How to understand... 如果将“指向T1的指针”的纯右值转换为“指向T2指针”类型时会移除常量性，则使用左值引用转换将T1的一个左值转换为T2的一个右值或者使用右值转换将T1的表达式转换为T2类型的消亡值时也会移除常量性。 注：一些仅仅涉及到修改cv限定符的转换也不能使用const_cast。例如：函数指针间的转换不能使用const_cast，因为这会导致未定义行为。同样的道理，成员函数指针间的转换，特别是将一个常量函数指针转换为非常量函数同样不能使用const_cast。 其余出现位置 P40 5.11 Keywords const_cast是一个关键词。 P89 6.8 Object lifetime 在常量对象所在内存上覆盖新建对象会造成未定义行为。 P121 8.2 Postfix expression const_cast是从左到右结合的后缀表达式。 P141 8.4 Explicit type conversion(cast notation) 表明const_cast功能被强制类型转换覆盖。 即：(new-type)expr覆盖const_cast(expr)功能。 P178 10.1.7.1 The cv-qualifiers 定义cv修饰符。 359 17.2 Names of template specialization 说明形如const_cast>最后的那个>>被解释为两个>而不是右移符号>>。 P372 17.5.3 Variadic templates 出现在变参模板的一个解释例子中，和const_cast本身关系不大。 P396 17.6.2.2 Type-dependent expression const_cast是类型依赖表达式的条件，和const_cast本身关系不大。 接下来是出现一系列函数的实现使用到了const_cast P633, 23.11.2.2.1 shared_ptr constructors P639, 23.11.2.2.9 chared_ptr casts P840, 26.2.1 General container requirements, 实现常量迭代器 P890, 26.3.9.3 forward_list iterators P1229, 30.8.3.3 basic_istringstream, Member functions P1231, 20.8.4.3 basic_ostringstream, Member functions P1233, 30.8.5.3 stringstream, Member functions P1242, 30.9.3.3 ifstream, Member functions P1244, 30.9.4.3 ofstream, Member functions P1247, 30.9.5.3 fstream, Member functions P1476, D.6.2.2 istrstream, Member functions P1427 Annex A 仅仅是罗列在后缀表达式中。 P1452 C.1.9 Clause 15: special member functions 有关volatile对象的复制问题。 P1523 Index 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"ISO_static_cast.html":{"url":"ISO_static_cast.html","title":"ISO static_cast.md","keywords":"","body":"ISO static_cast Ref: ISO/IEC 14882 定义 P127 8.2.9 Static cast static_cast(v)的结果就是把v转换为T类型的结果。 如果T是左值引用类型或者引用至函数的右值引用类型，转换结果是左值。 如果T是对对象的右值引用，结果是消亡值。其他情况下，结果是纯右值。 static_cast不能去除常量性。 假设B是一个类类型(class type)、D是B的一个子类，在cv2等于cv1或限制比cv1更强时，一个cv1 B类型的左值可以转换为cv2 D的引用类型。 如果B是D的虚基类、D的虚基类的基类，或者如果不存在从“指向D的指针”向“指向B的指针”的标准转换，那么程序是非规范的。 一个cv1 B类型的消亡值可以被转换为与类型cv1 B拥有相同限制的cv2 D的右值引用类型。 如果cv1 B的一个对象确实是类型D的一个对象的基类子对象，转化结果将指向那个封闭(enclosing)类型D的对象。 其他情况下，转化行为是未定义的。例如： struct B{}; struct D : public B{}; D d; B &br = d; static_cast(br); // 结果是指向最初d对象的左值引用。 如果cv2 T2与cv1 T1是引用兼容的(11.6.3)，一个cv1 T1类型的左值可以被转换为cv2 T2的右值引用. 如要转换的值不是位域(bit-field)，则转换结果就指向那个对象或者是那个对象的基类子对象；否则，将对位域进行左值到右值的转换(7.1)，并把转换得到的纯右值作为static_cast的表达式部分。 如果T2是T1的不可访问或有歧义基类，则包含这样的代码的程序是非规范的。 对于static_cast(e)： 如果存在一条从e到T的隐式转换链，或者至少重载了一个可用的从e的对象或引用直接初始化(direct-initialization)T的函数，那么e可以被转换为T类型。 如果T是一个引用类型，效果等价为先执行T t(e);再把 t 作为转换的结果。否则，结果对象从e直接初始化而来。 注：当尝试把一个表达式转化为它的不可访问或者有歧义基类类型时，这个转换是非规范的。 除上述情况，static_cast将执行下述转换，且没有其他转换可以使用static_cast。 所有表达式都可以被转化为cv void类型，这种情况下表达式会变成值被抛弃的表达式(术语 8)。注：但如果这个值存在于临时对象(15.2)中，因为这个对象需要在之后调用析构函数，这个对象会被保留。 如果一个标准转换链(术语 7)并不包含左值到右值(7.1)、数组到指针(7.2)、函数到指针(7.3)、空指针(7.11)、空成员指针(7.12)、布尔转换(7.14)、函数指针转换(7.13)，那么可以通过static_cast执行这个转换链的逆向转换。如果一个标准转换链是非规范的，则它的逆向转换也是非规范的。例： struct B {}; struct D {} : private B{}; void f(){ static_cast((B*)0); // 错误：B 是 D 的私有基类。 static_cast((int D::*)0); // 同上。 } static_cast也可以执行左值到右值(7.1)、数组到指针(7.2)、函数到指针(7.3)的转换，但存在限制：不能去除常量性(8.2.11)，且对于下述特殊情况有额外限制： 一个限域枚举可以被显式转换为一个整型类型。当目标类型是cv bool时，如果原来的值为0，转换结果为是false；其他情况下，结果未true。对于其他整型类型，如果目标类型可以表示原有值，那么原有值不会被改变。除此之外，结果的值是不确定的。 一个限域枚举的值也可以被显式转化为浮点类型，转化结果就是把原有值转换为浮点类型。 一个整型类型或枚举类型的值可以被显式转化为类型完整的枚举类型。如果原有值在枚举值域内，值不会被改变。其他情况下，转换行为是未定义的。 一个浮点类型的值也可以被显式转化为枚举类型。转化结果等价为先把原有值转化为枚举的底层类型，然后再转化为枚举类型。 设B为类类型，一个cv1 B类型的纯右值指针可以被转化为cv2 D类型的纯右值指针，这里D是B的子类且cv2与cv1相同或更强。 如果B是D的虚基类或D的虚基类的基类，或不存在从D类型指针到B类型指针的标准转换，那么程序是非规范的。 空指针类型可以被转换为目标类型的空指针。 如果一个cv1 B类型的指针指向一个B对象，且这个对象是一个类型D对象的子对象，转换结果为指向那个封闭类型D对象的指针。 其他情况下，行为是未定义的。 一个”指向D的cv1 T类型成员的指针“可以被转换为”指向cv2 B类型成员的指针“，这里B是D的基类且cv2不比cv1弱。 如果不存在从“指向B的T类型成员指针”到“指向D类型的T类型成员指针”的标准转换，程序是非规范的。 空成员指针可以转化为目标类型的成员指针。 如果类B包含原有成员，或是包含了原有成员的基类或子类，则转化结果指向原有成员。除此之外，行为是未定义的。注：虽然类B不需要包含原有成员，这个被执行转化的指针的间接对象的动态类型必须包含原有成员。 当T是一个对象类型且cv2不比cv1弱时，一个“cv1 void类型指针”可以被转换为“cv2 T类型指针”。 如果原指针的值代表内存中一个字节的地址A，A不满足T的内存对齐要求，那么结果指针的值是不确定的。 除此之外，如果原指针指向一个对象a且存在一个T类型对象b，在忽略cv限定符的情况下与a是指针兼容的(6.9.2)，则结果是指向b的对象。例如： T* p1 = new T; const T* p2 = static_cast(static_cast(p1)); bool b = p1 == p2; // b = true。 其他出现static_cast位置 P40 5.11 Keywords static_cast是c++预留关键字。 P53 6.3 Declarations and definitions 条目 3 出现在对C++自动生成的默认移动构造函数、移动赋值函数中，利用的是static_cast(expr)强制转化为右值语义。 P55 6.2 One-definition rule 条目 5.6 使用static_cast进行转换的某些情况下需要要求类型是完整的。 P87 6.8 Object lifetime 条目 6.4 在对象内存已经分配但对象生命周期还未开始、对象生命周期已经结束但内存还未回首时的static_cast的行为。 P106 8 Expressions 条目 7.4 说明了导致消亡值的一些情况，stati_cast的一种使用方法是其中之一。 P121 8.2 Postfix expressions 条目 1、条目2 static_cast是从左至右结合的后缀表达式。 static_cast中type-id后可能会出现符号>>会被理解为两个>而不是右移符号>>。 P130 8.2.10 Reinterpret cast 条目6 reinterpret_cast的一种转换情况等价于使用两次连续的static_cast P141 8.4 Explicit type conversion (cast notation) 条目2、条目4.2、条目4.8、条目5 条目2：显示类型转换可以用static_cast。 条目4.2：说明static_cast也可以使用C风格的强制类型转换完成，除了某些特别情况，编译器采取相同的语义限制。 条目4.8：如果紧接着static_cast再进行const_cast且这个转换有不止一种转换路径，这种转换是非规范的。 例如: struct A {}; struct I1 : A {}; struct I2 : A {}; struct D : I1, I2 {}; A *foo(D* p){ return (A*)(p); // 非规范的`static_cast`转换。 } 条目5：当强制转换涉及到指向不完整类型的纯右值指针时，强制类型转换的特殊行为。 P235 11.6 Initializers 条目16 通过static_cast等等方式（详细见标注文档）进行的初始化称之为直接初始化（direct-initialization）。 P242 11.6.3 References 条目5.2.1.2 有关引用的初始化。 P297 15.3.1 Conversion by constructor 条目2 有explicit修饰的构造函数可以被static_cast显示调用。 P315 15.8.1 Copy/move constructors 条目14.2 static_cast参与到默认生成的复制构造函数、移动构造函数的行为中。 P359 17.2 Names of template specializations 脚注136） 基本同P121的说明，同样是把的>>理解为两个>。 P396 17.6.2.2 Type-dependent expressions 条目3.8 static_cast将导致类型依赖表达式（type-dependent expressions） P397 17.6.2.3 Value-dependent expressions 条目3 static_cast(expression)是值依赖(value-dependent)的条件。 P464 20.4.2.1.4 Bitmask types 条目2 P476、478 20.5.3.5 Allocator requirements 表31 Allocator requirements、条目6 表31：对内存分配器的要求。 条目6：static_cast参与相等关系的判定。 以下条目都是使用static_cast来描述一些函数的效果： P491，21.2.5 byte type operations。 P535，22.5.3.5 Class error_code non-member functions。 P537，22.5.4.5 Class error_condition non-member functions。 P545，23.2.5 Forward/move helpers，转发函数和移动函数。 P575，23.6.3.5 Observers，条目19。 P597，23.8.4 Non-member functions，条目6。 P615，23.10.8.2 Allocator traits static member functions，条目5。 P616-618，23.10.10 Specialized algorithms。 P639，23.11.2.2.9 shared_ptr casts。 P649，23.12.3.2 polymorphic_allocator member functions，条目1 P660，23.13.4 Scoped allocator adaptor members，条目3、条目4 P666，23.14.2 Function object, requirements，条目1.7 P721，23.17.5.1 duration constructors，条目3 P724，23.17.5.7 duration_cast，条目2 P752，24.3.2.2 basic_string constructors and assignment operators，条目16 P757，24.3.2.6.2，条目25 P795，25.3.1.1.2 Class locale::facet，条目3 P830，25.4.6.3 Class template moneypunct，条目1 P987，27.5.3.3.4 move_iterator::operator* P1070，29.5.10 Suffixes for complex number literals，条目2、条目3、条目4 P1187，30.5.6.5 Error reporting，条目1、条目2 P1202，30.7.4.2.2 Arithmetic extractors， 条目2、条目3 P1214，30.7.5.2.2 Arithmetic inserters，条目1 P1290，30.10.15.7 Create directory，条目1 P1293，30.10.15.14 File Size，条目1 P1293，30.10.15.15 Hard link count P1297，30.10.15.31 Remove all P1298，30.10.15.34 Space P1405，33.6.3 Error handling P1427 Annex A 列表 postfix-expression Index P1528、P1545 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"ISO_reinterpret_cast.html":{"url":"ISO_reinterpret_cast.html","title":"ISO reinterpret_cast.md","keywords":"","body":"ISO reinterpret_cast Ref: ISO/IEC 14887 对intepret_cast的定义 P129 8.2.10 Reinterpret cast reinterpret_cast(v)的结果是把v转化为T类型。当T是左值引用类型或对函数的右值类型时，结果是左值；如果T是对对象的右值引用类型，结果是消亡值；其他情况下，结果是纯右值且将对v执行左值到右值、数组到指针、函数到指针的标准转换。仅有如下列举的转换可以通过reinterpret_cast执行。 reintperpret_cast不能去除常量性。一个整型、枚举型、指向成员指针类型可以被显式转换本身的类型；这样转换的结果就是原操作数的值。 注：reinterpret_cast执行的映射可能会、也可能不会造成与原有值的改变。 一个指针可以转换为任意足够大的整型。此时映射函数依赖于具体实现[注：对于那些熟知机器底层地址架构的人来说，这一点不会使他们惊讶。] 一个std::nullptr_t类型的值可以转换为整型类型，这个转换的含义及合法性与将(void*)0转换为整型是相同的。[注：reinterpret_cast不能把任何类型的值转换为std::nullptr_t。] 一个整型类型或枚举类型的值可以显式地转换为指针。把一个指针转换为一个足够大的整型类型再转换回原指针类型的值就是最初指针的值；否则指针和整型之间的映射关系是实现依赖的。注：除了6.7.4.3描述的情况外，这样的转换不会是一个safely-derived类型的指针。 一个函数的指针可以显式地转换为另一个函数类型的指针。[注：尝试把一个函数指针转换为另一个函数指针类型后再调用将导致未定义行为。] 除了把“指向T1的纯右值指针”转换为“指向T2的指针”(这里T1和T2是函数类型)再转换回原类型的结果就是原指针的值以外，这样的指针转换结果是不确定的。[注：对于指针转换更详细的细节，参见7.11] 一个对象的指针可以转换为另一类型的对象的指针。1 当一个对象纯右值指针类型被转换为“指向 cv T”的指针类型时，结果等价为static_cast(static_cast(v))。[注：把“指向T1”的纯右值指针转换为“指向T2”的指针且T1、T2都是对象类型且T2的对齐要求不比T1严格时，再把结果转换回原类型得到的指针值等于最初的指针值。] 在某些情况下，把函数指针转换为对象指针或反方向转化是得到支持的。这样的转化的含义依赖于具体实现，除非某个实现支持两个方向的转化，把一个类型的纯右值转化为另一个类型再转换原类型，尽管cv限定符可能有所不同，但其值就是最初指针的值。 空指针的值可以转换为目标类型的空指针。注：一个std::nullptr_t类型的空指针常量不能被转换为一个指针类型，且一个整型类型的空指针常量没有必要转换为空指针。 一个“指向T1类型的X成员”的纯右值指针可以被显式地转换为一个不同的“指向T2类型的Y成员的纯右值指针”，这里T1和T2都是函数类型或都是对象类型。2 成员空指针可以被转换为目标类型的成员空指针。除了下述情况外，其他转换的结果是不确定的： 把“指向成员函数的指针“转换为另一个指向成员函数指针类型，再把它转换回原来的类型得到的指针就是最初的指针。 把一个“指向T1类型X成员数据的指针”转换为“指向T2类型的Y成员”的指针(这里要求T2的内存对齐要求不比T1严格)，再把它转换为原来的类型，得到的就是最初的指针。 如果“指向T1的指针“类型可以使用reinterpret_cast显式地转换为“指向T2的指针”类型，那么一个T1类型的泛左值表达式可以被转换为T2类型的引用。结果指向与原泛左值相同的对象，但对象的类型有所不同。[注：意思是对于左值，reinterpret_cast(x)与*reinterpret_cast(T*)(&x)有相同的效果，对于reinterpret_cast(x)同理] 这个转换不会创建任何临时对象、不会进行任何拷贝、不会调用构造函数或转换函数。3 上标解释部分： & 2. 在reinterpret_cast不能去除常量性的条件下，这些类型可能具有不同的cv限定符。 这有时被称为类型双关(type pun)。 其余出现位置 P40 5.11 Keywords 表格5 reinterpret_cast是保留关键字。 P85 6.7.4.3 Safely-derived pointers 条目2、条目3、条目4 条目2：有关safely-derived pointer的定义。 条目3：整型值是safely-derived指针的整型表现的条件。 条目4：对于两个可互换对象的指针，可以通过reinterpret_cast从一个指针获取另一个指针。 P121 8.2 Postfix expression 条目1、条目2 条目1：reinterpret_cast是后缀表达式。 条目2：在解析reinterpret_cast时，>>符号被理解为两个>而不是右移符号。 P141 8.4 Explicit type conversion (cast notation) 条目2、条目4、条目5 条目2：可以使用reinterpret_cast进行显示隐式转换。 条目4：reinterpret_cast的功能被C语言风格的转换语法覆盖。 条目5：如果源类型和目标类型都是不完整类型，reinterpret_cast的结果是不确定的。 P152 8.20 Constant expressions 条目2 与一个表达式是核心常量表达式(core constant expression)的条件有关。 P396 17.6.2.2 Type-dependent expressions 条目3 与类型依赖相关。 P397 17.6.2.3 Value-dependent expressions 条目3 当type-id或expression是值依赖(value-dependent)时，reinterpret_cast是值依赖的。 P640 23.11.2.2.9 shared_ptr cast 条目10、条目11、条目12 使用reinterpret_cast定义了一系列的函数。 P1061 29.5 Complex numbers 条目4 这一条比较有意思。 假设z是类型cv complex的一个左值，那么： 表达式reinterpret_cast(z)是规范良好的(well-formed)。 reinterpret_cast(z)[0]代表 z 的实部，且 reinterpret_cast(z)[0]代表 z 的虚部。 更进一步，如果a的类型是cv complex*且对于整型i表达式a[i]是规范良好的，那么： reinterpret_cast(a)[2*i]代表a[i]的虚部，且 reinterpret_cast(a)[2*i+1]代表a[i]的实部。 P1216 30.7.5.2.4 character inserter function templates 条目4 借助reinterpret_cast来定义函数。 P1427 附录A P1542 索引 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"updown-cast.html":{"url":"updown-cast.html","title":"向上、向下转换","keywords":"","body":"尴尬的向下转换 约定： 向上转换：向基类转换 向下转换：向子类转换 引言 在一个继承体系中，最常做的一件事就是把子类的对象付给基类类型的变量，通过多态性来实现程序的功能。这一步没有什么好说的，直接赋值就完事了。但也有迫不得已的尴尬情况：必须把一个父类类型的变量转换回子类类型，这样的向下转换可能是危险的，毕竟我们不知道变量指向的对象是不是真的是目标类型。此时我们面前的有两种转换运算符可以选择： static_cast dynamic_cast 二者的使用方法可以参照简要说明、详细说明和定义部分，这里仅做如下归纳： 若能不使用向下转化，就不使用向下转化。 若体系中无虚函数表，只能选择static_cast。 若继承体系不是非常庞大，转换次数较少，首选dynamic_cast。 若继承体系庞大，转换频繁，考虑使用static_cast以提高程序性能。 但其实一般来说都不需要考虑dynamic_cast的效率问题。 上述归纳的原因在于： static_cast不会进行类型检查，所以容易出错。 dynamic_cast依托虚函数表工作，虽然运行时检查提高安全性，但一层层查看虚函数表会降低程序性能。 dyanmic_cast性能问题 现在我们来实际实验一下dynamic_cast与static_cast的性能对比。 该小结对应文件夹路径为./asset/dyn-eff，并作为下文路径的根目录。 对比思路 构造一个具有100层继承关系的复杂继承体系，使每个类都有自己的虚方法来让虚函数表膨胀，然后把用根父类指针指向一个叶子子类的对象，然后重复不断地转化回某个合法的子类对象(这一步目的是让static_cast也能合理地转化指针，简化代码)，记录程序使用时间。 实际操作 由于代码又臭又长，下文都不展示代码。 先使用python生成继承体系，对应code-gen文件夹。 stt-cast.cpp用于测试static_cast，dyn-cast.cpp用于测试dynamic_cast.cpp。被测量部分代码都被重复十万次，保证效果明显。且借助assert防止编译器优化代码。在MSVC Debug，关闭所有优化选项下编译运行。 测试结果 & 结论 结果大致如下： static_cast：0.004s dynamic_cast：0.3s 确实dynamic_cast效率远低于static_cast。 但说实话，如果程序需要进行这么多次向下转换，我觉得是不是得考虑重构代码了。所以一般来说我们不需要考虑dynamic_cast的效率问题。 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "},"static-poly.html":{"url":"static-poly.html","title":"静态多态性","keywords":"","body":"静态多态性 Ref：Curiously recurring template pattern 借助模板和static_cast，我么可以实现有别于虚函数表的另一种多态：静态多态。 见如下代码： //snippet: static-poly.cpp template class Base { public: void greeting() { static_cast(this)->hello(); } static void static_greeting(){ T::static_greeting(); } }; class Bob : public Base { public: void hello(){ cout *bob = new Bob; Base *alice = new Alice; bob->greeting(); alice->greeting(); Base::static_greeting(); Base::static_greeting(); 输出： This is Bob. This is Alice. This is static Bob. This is static Alice. 这就完成了静态多态的一种实现方法。这种静态多态的效率比通过虚函数表实现的动态多态要高一些，但是会失去一些灵活性。 Windows的ATL库和WTL库广泛采用了这种技术。 本作品采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。最近更新： 2021-06-01 "}}